---
layout: essay
type: essay
title: "Relating Game Patterns to Software"

date: 2025-04-15
published: true
labels:
  - Software Engineering
  - VScode
summary: "Relating Game Patterns to Software Design"
---

<div style="display: flex; justify-content: center; align-items: center;">
<img src="/img/Zeldaa.png" alt="Coding Standards" style="display: block; margin: auto; width: 300px; heigt: auto">
  
</div>

### Design Patterns = Combat Patterns
<p> In game development, enemy behavior patterns create a predictable rhythm so players can learn, adapt, and feel a sense of mastery. Software design patterns serve the same purpose in code: they are repeatable solutions to common problems in programming, structured in a way that developers can learn and reuse. They bring order to complexity, just like patterns bring strategy to chaos in Hyrule.

Take the Singleton Pattern, for example. It’s a way to ensure that there’s only one instance of something in your application like the Sheikah Slate in Zelda. You don’t want multiple game state managers or multiple database connectors running wild. You want one, and only one, to coordinate everything just like how there’s one Sheikah Slate that holds all your runes, maps, and warp points.


### When the most difficult of enemies is ESLint
<p> Of course, no journey is complete without a few unexpected boss fights. For me, one of the biggest challenges wasn’t figuring out how to use Vercel or Supabase; it was getting my app to build without tripping over a dozen ESLint errors. Every time I fixed one rule, another seemed to spawn, like a coding version of a Hydra. I quickly learned that ESLint was less of a monster and more of a gatekeeper to clean, maintainable code. It forced me to think more like a designer that organizes imports, avoids bad loops, and writing cleaner functions. Eventually, I began to recognize the pattern behind the errors. Like parrying a Guardian’s laser, I stopped reacting and started anticipating. What began as frustration became fluency. </p>
